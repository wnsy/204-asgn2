---
title: "204-asgn2"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
.libPaths("H:/R")
library(ggplot2)
#library(plyr)
```

#Group members
- Ayesha Wan Ismail
- Bhavisha Solanki
- Ruth Banda

# Problem setup - load data and exploratory data analysis (EDA)
We'll start by looking at the "Abalone" data. 

The data is supplied in a CSV file. Let's start by loading this into R:
```{r load data, echo=TRUE}
abalone <- read.csv("abalone.csv")
f <- rings~.
```

As the abalone adds one ring to their shell each year but their first year, we could estimate the age of the abalone fairly precise by adding 1.5 to the number of rings (Credit: [Cleaning abalone data]). 


Now, we should split the data into two parts - a section for exploration and training, and another for testing.

```{r split abalone data, echo=TRUE}
train.idx <- sample(nrow(abalone), 0.5*nrow(abalone))
abalone.train <- abalone[train.idx, ]
abalone.test  <- abalone[-train.idx, ] ## note the negative indexing to REMOVE instances!
```


We should start by looking at some basic descriptive information about the data:
```{r EDA.1, echo=TRUE}
 summary(abalone.train)
```
Here, we focus on the training data instead of the entire data so that when we modify our features like doing  transformations will offer good generalisation performance.

As shown above, we are dealing with continuous data, hence the response for the number of `Rings` is our continuous data making it a regression problem. 

Then we are looking to plot the response (the measured number of rings):
```{r EDA.2, echo=TRUE}
hist(abalone.train$rings)
```

 
```{r EDA.3, echo=TRUE}
 cor(abalone.train[, -1])
 cor(abalone.test[ , -1])
```
get rid of length, height,weight.shucked, weight.viscera


```{r EDA.4, echo=TRUE}
abalone.train$length <- NULL
abalone.train$height <- NULL
abalone.train$weight.shucked <- NULL
abalone.train$weight.viscera <- NULL

abalone.test$length <- NULL
abalone.test$height <- NULL
abalone.test$weight.shucked <- NULL
abalone.test$weight.viscera <- NULL

```


Next, we should examine the correlations in our data:
```{r EDA.5, echo=TRUE}
plot(abalone.train, pch=19, col="orange")
```


Let's look at the weight of the whole abalone first: 
```{r EDA.2.1, echo=TRUE}
qplot(rings,
      data = abalone,
      geom = "histogram")
```

However, we are more interested in finding whether different sexes affect the distributions. So we have to make separate plots for each sex by using `facets` argument in the `qlot()` function. It will have the tilde on the left hand side to let us know that what variable we have to separate the data by for vertically arranged panels and the right hand side lets us know what variable we want to separate by for horizontal panels. If we want only one and not both, we can use a period for the other axis, like below. The `binwidth` argument is added so `ggplot` will no longer complain (Source: [Cleaning Abalone data]).

```{r EDA.2.2, echo=TRUE}
qplot(rings,
      data = abalone,
      geom = "histogram",
      facets = sex~.,
      binwidth = 20)
```

```{r EDA.2.2 sex and ordered factor, echo=TRUE}
abalone$sex <- ordered(abalone$sex,
                       levels = c("I", "M", "F"),
                       labels = c("Infant", "Male", "Female"))

#redo histogram
qplot(rings,
      data = abalone,
      geom = "histogram",
      facets = sex~.,
      binwidth = 20)
```

```{r EDA.2.3 boxplot, echo=TRUE}
qplot(sex, rings,
      data = abalone,
      geom = "boxplot",
      fill = sex)
```




```{r EDA.2.4, echo=TRUE}
qplot(diameter, rings, 
      data = abalone, 
      color = sex)
```
      
      
     
```{r EDA.2.5, echo=TRUE}
qplot(diameter, rings, 
      data = abalone, 
      color = sex)  +
  geom_smooth(slope = 1)
``` 
     
```{r save, echo=TRUE}  
     save(abalone, file = "abalone_trimmed.Rdata")
```
     
## Regression - k-Nearest Neighbours (kNN)

We are trying to predict the age of the abalone based on the diameter of the shell. They grow by adding new layers to their shell, which means there is an increase of the shell diameter, in addition to the entire inside of the shell which will increase the thickness of the shell (Source: [Abalone Reproduction and Growth])

```{r MSE, echo=TRUE}
MSE <- function(y, yhat) mean((y - yhat)^2)

RSQ <- function(y, yhat) 1 - sum((y - yhat)^2) / sum((y - mean(y))^2)
```


```{r knn predict, echo=TRUE}
knn <- function(f, data, k=1) {
  known.X <- scale(model.matrix(f, data)[, -1])
  known.y <- model.response(model.frame(f, data))
  
  structure(list(k=k, f=f, known.X=known.X, known.y=known.y), class="knn")
}

predict.knn <- function(knn, newdata) {
  if (class(knn) != "knn") stop("Supplied model was not a k-Nearest Neighbour object")
  
  known.X <- knn$known.X
  known.y <- knn$known.y
  
  X <- scale(model.matrix(knn$f, newdata)[, -1], 
             scale=attr(known.X, "scaled:scale"), 
             center=attr(known.X, "scaled:center"))
  
  k.nearest <- matrix(apply(X, 1, function(X.i, known.X, known.y, k) {
    d <- rowSums(sweep(known.X, 2, X.i)^2)
    known.y[head(order(d), k)]
  }, known.X=known.X, known.y=known.y, k=knn$k), nrow=knn$k)
  
  if (is.factor(known.y)) {
    factor(apply(k.nearest, 2, function(neighbours) {
      t <- table(neighbours)
      names(t[which.max(t)])
    }), levels=levels(known.y), ordered=is.ordered(known.y))
  } else if (is.character(known.y)) {
    apply(k.nearest, 2, function(neighbours) {
      t <- table(neighbours)
      names(t[which.max(t)])
    })
  } else {
    colMeans(k.nearest)
  }
}
```

apply for loop over 2 columns, 1 loop over the rows
regression take out factor and character 

```{r EDA.8, echo=TRUE}

evaluate.knn <- function(f, train, test, error, k) {
  mdl <- knn(f, train, k)
  
  ## extract the known outcomes from the test set
  y <- model.response(model.frame(f, test))
  
  ## obtain the model predictions on the test data
  yhat <- predict(mdl, test)
  
  ## returns the error of the predictions (e.g., MSE)
  error(y, yhat)
}

evaluate.knn.cv <- function(f, data, K, folds, error, knn.k) {
  mean(sapply(seq(K), function(k) {
    leave.in <- data[folds != k, ] ## data not in our current fold
    hold.out <- data[folds == k, ] ## data in our current fold
    
    evaluate.knn(f, leave.in, hold.out, error, knn.k)
  }))
}

K <- 10
folds <- sample(rep(seq(K), length.out=nrow(abalone.train)))

knn.k <- c(1, 2,3	,5,	8,	13,	21,	34,	55,	89,	144,	233,	377,	610)
wse <- rep(NA, length(knn.k))
cve <- rep(NA, length(knn.k))
for (j in seq_along(knn.k)) {
  wse[j] <- evaluate.knn(f, abalone.train, abalone.train, MSE, knn.k[j])
  cve[j] <- evaluate.knn.cv(f, abalone.train, K, folds, MSE, knn.k[j])
  cat(".")
}
cat("\n")
```

LINE 169 parameters looking at knn(want something that starts off small and gets bigger and useful. samll gives nice spread and bigger doesn't)
sapply= apply ans simplify

```{r EDA.9, echo=TRUE}
plot(knn.k, wse, type="l", lwd=2, col="orange", ylab="Error", ylim=range(c(0, wse, cve)))
lines(knn.k, cve, lwd=2, col="purple")
abline(h=min(cve), lty=2, col="gray")
abline(v=knn.k[which.min(cve)], lty=2, col="gray")
text(knn.k[which.min(cve)], min(cve), sprintf("CV-min=(%d, %.2f)", knn.k[which.min(cve)], min(cve)), col="gray", adj=c(-0.05, -0.5))
legend("bottomright", c("Within-Sample", "Out-of-Sample (CV)"), col=c("orange", "purple"), lwd=2, bty="n")

```


```{r , echo=TRUE}
k.selected <- knn.k[which.min(cve)]
knn.mdl <- knn(f, abalone.train, k.selected)
yhat.knn <- predict(knn.mdl, abalone.test)
```


## (Insight)
 We also want to gain an insight of the age of the abalone based on the diameter of the shell in correlation to the number of rings (response) on the shell. This is because the abalone growth rings is due to feeding which resulted in concentric rings that are laid down at the outermost edge of the shell. They have circular patterns which can also help us predict the age of the abalones and the types of food that are available to them when they are young. 
 
## Linear Modelling 


```{r lm.part1 , echo=TRUE}
abalone.lm <- lm(f, abalone.train)
yhat.lm <- predict(abalone.lm, abalone.test)

```


```{r aval lm.part1 , echo=TRUE}
print(MSE(abalone.test$rings, yhat.lm))
print(RSQ(abalone.test$rings, yhat.lm))

```

```{r summary.lm , echo=TRUE}
summary(abalone.lm)

```





[Abalone Reproduction and Growth]: http://www.marinebio.net/marinescience/06future/abrepro.htm

[Cleaning Abalone data]: http://shapbio.me/courses/biolB215s13/abalone_cleaning.html